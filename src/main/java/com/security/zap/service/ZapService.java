package com.security.zap.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import org.apache.hc.client5.http.classic.methods.HttpGet;
import org.apache.hc.client5.http.config.RequestConfig;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.core5.util.Timeout;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.zaproxy.clientapi.core.ApiResponse;
import org.zaproxy.clientapi.core.ApiResponseElement;
import org.zaproxy.clientapi.core.ApiResponseList;
import org.zaproxy.clientapi.core.ClientApi;

@Service
public class ZapService {

	private final ObjectMapper mapper = new ObjectMapper();
	private final CloseableHttpClient httpClient;
	private final ClientApi clientApi;

	@Value("${spring.zap.api}")
	private String ZAP_API;

	@Value("${spring.zap.key}")
	private String ZAP_KEY;

	public ZapService(ClientApi clientApi) {
		RequestConfig config = RequestConfig.custom()
				.setConnectTimeout(Timeout.ofSeconds(30))
				.setResponseTimeout(Timeout.ofSeconds(60))
				.build();

		this.clientApi = clientApi;
		this.httpClient = HttpClients.custom().setDefaultRequestConfig(config).build();
	}

	/**
	 * Creates a new session with the given session name. If a session with the same name already exists,
	 * it can be optionally overwritten based on the provided overwrite flag.
	 * @param sessionName the name of the session to be created
	 * @param overwrite whether to overwrite an existing session with the same name (true to overwrite, false otherwise)
	 * @throws Exception if an error occurs while creating the session
	 */
	public void newSession(String sessionName, boolean overwrite) throws Exception {
		clientApi.core.newSession(sessionName, String.valueOf(overwrite));
	}

	/**
	 * Checks if the given URL is known to the ZAP API.
	 * @param url the URL to check for its presence in the list of known URLs
	 * @return true if the URL is known, false otherwise
	 * @throws Exception if there is an error while fetching the list of known URLs from the API
	 */
	public boolean isUrlKnown(String url) throws Exception {
		ApiResponse resp = clientApi.core.urls("");
		if (resp instanceof ApiResponseList list) {
			for (ApiResponse item : list.getItems()) {
				if (item instanceof ApiResponseElement) {
					String knownUrl = ((ApiResponseElement) item).getValue();
					if (knownUrl.equals(url)) {
						return true;
					}
				}
			}
		}
		return false;
	}

	/**
	 * Initiates a new active scan for the specified URL using the ZAP API.
	 * @param url the URL to be scanned
	 * @return the scan ID of the initiated scan
	 * @throws IOException if an error occurs while communicating with the ZAP API
	 */
	public String startScan(String url) throws IOException {
		String response = callZap(ZAP_API + "/JSON/ascan/action/scan/?apikey=" + ZAP_KEY + "&url=" + url);
		return mapper.readTree(response).get("scan").asText();
	}

	/**
	 * Retrieves the progress percentage of an active scan based on the scan ID.
	 * The progress is returned as an integer representing the completion percentage of the scan.
	 * @param scanId the unique identifier of the scan whose progress is to be retrieved
	 * @return an integer value representing the scan completion percentage
	 * @throws IOException if an error occurs while communicating with the ZAP API
	 */
	public int getScanProgress(String scanId) throws IOException {
		String resp = callZap(ZAP_API + "/JSON/ascan/view/status/?scanId=" + scanId + "&apikey=" + ZAP_KEY);
		return mapper.readTree(resp).get("status").asInt();
	}

	/**
	 * Retrieves the HTML report generated by the ZAP API.
	 * The report contains the results of the security scan in an HTML format.
	 * @return a string containing the HTML report
	 * @throws IOException if an error occurs while communicating with the ZAP API
	 */
	public String getHtmlReport() throws IOException {
		return callZap(ZAP_API + "/OTHER/core/other/htmlreport/?apikey=" + ZAP_KEY);
	}

	/**
	 * Accesses the provided URL using the ZAP API.
	 * This method triggers ZAP to make a request to the target URL, with redirections being followed.
	 * @param targetUrl the URL to be accessed
	 * @throws IOException if an error occurs during communication with the ZAP API
	 */
	public void accessUrl(String targetUrl) throws IOException {
		callZap(ZAP_API + "/JSON/core/action/accessUrl/?apikey=" + ZAP_KEY
				+ "&url=" + URLEncoder.encode(targetUrl, StandardCharsets.UTF_8)
				+ "&followRedirects=true");
	}

	/**
	 * Executes an HTTP GET request to the specified URL and retrieves the response content as a string.
	 * This method is used internally to communicate with the ZAP API.
	 * @param url the URL to send the HTTP GET request to
	 * @return the response content as a string
	 * @throws IOException if an error occurs during the HTTP request execution or while reading the response
	 */
	private String callZap(String url) throws IOException {
		HttpGet request = new HttpGet(url);
		return httpClient.execute(
				request,
				httpResponse ->
						new String(httpResponse.getEntity().getContent().readAllBytes(), StandardCharsets.UTF_8));
	}

	/**
	 * Checks whether an active scan is currently in progress.
	 * @return true if an active scan is still running (progress is less than 100), false otherwise.
	 * @throws IOException if an error occurs while communicating with the ZAP API.
	 */
	public boolean isScanRunning() throws IOException {
		String response = callZap(ZAP_API + "/JSON/ascan/view/status/?scanId=0&apikey=" + ZAP_KEY);
		JsonNode root = mapper.readTree(response);
		int progress = root.has("status") ? root.get("status").asInt() : 100;
		return progress < 100;
	}
}
